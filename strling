#!/bin/bash
set -o pipefail

# Resolve script directory to locate toolchain.json
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
TOOLCHAIN="$DIR/toolchain.json"

# Where python virtualenv will live when using python binding
VENV_DIR=".venv"

# Check for python3 early as it is required for JSON parsing
if ! command -v python3 &> /dev/null; then
    echo "Error: python3 is required to run this script."
    exit 1
fi

COMMAND=$1
LANG=$2

# Help / Usage
print_banner() {
    echo "   _____ _______ _____  _ _             "
    echo "  / ____|__   __|  __ \| (_)            "
    echo " | (___    | |  | |__) | |_ _ __   __ _ "
    echo "  \___ \   | |  |  _  /| | | '_ \ / _\` |"
    echo "  ____) |  | |  | | \ \| | | | | | (_| |"
    echo " |_____/   |_|  |_|  \_\_|_|_| |_|\__, |"
    echo "                                   __/ |"
    echo "                                  |___/ "
    echo ""
}

list_bindings() {
    echo "Available Bindings:"
    # Get list of languages and their check_bin
    # We use a python script to output "lang:check_bin" pairs
    python3 -c "import json; 
data=json.load(open('$TOOLCHAIN')); 
bindings=data['bindings']; 
sorted_keys=sorted(bindings.keys()); 
for k in sorted_keys: print(f\"{k}:{bindings[k].get('check_bin', '')}\")" | while read -r line; do
        LANG_NAME="${line%%:*}"
        CHECK_BIN="${line#*:}"
        
        if [ -z "$CHECK_BIN" ]; then
            STATUS="[UNKNOWN]"
        elif command -v "$CHECK_BIN" &> /dev/null; then
            STATUS="[INSTALLED]"
        else
            STATUS="[MISSING ($CHECK_BIN)]"
        fi
        printf "  %-12s %s\n" "$LANG_NAME" "$STATUS"
    done
}

print_help() {
    print_banner
    echo "Usage: ./strling <command> <language>"
    echo ""
    echo "Commands:"
    echo "  setup <lang>      Install dependencies for a binding"
    echo "  test <lang>       Run tests for a binding"
    echo "  clean <lang>      Clean artifacts for a binding"
    echo "  cache-dir <lang>  Print cache directory path (for CI)"
    echo "  lockfile <lang>   Print lockfile name (for CI)"
    echo "  list              List all bindings and tool status"
    echo "  help              Show this help message"
    echo ""
    echo "Examples:"
    echo "  ./strling test python"
    echo "  ./strling setup rust"
    echo "  ./strling cache-dir php"
    echo ""
    list_bindings
}

if [ -z "$COMMAND" ] || [ "$COMMAND" == "help" ] || [ "$COMMAND" == "-h" ] || [ "$COMMAND" == "--help" ]; then
    print_help
    exit 0
fi

if [ "$COMMAND" == "list" ]; then
    print_banner
    list_bindings
    exit 0
fi

# cache-dir: Print the cache directory path for a given language (for CI caching)
# Outputs only the path to stdout, no extra logging, for easy consumption by CI
# NOTE: We cache both package manager caches AND build outputs for maximum efficiency
if [ "$COMMAND" == "cache-dir" ]; then
    if [ -z "$LANG" ]; then
        echo "" # Empty output for missing lang
        exit 1
    fi
    case "$LANG" in
        php)
            # Composer cache (Linux default) + vendor directory for installed packages
            echo "${HOME}/.cache/composer"
            echo "bindings/php/vendor"
            ;;
        typescript|javascript|node)
            # npm cache + node_modules for installed packages
            echo "${HOME}/.npm"
            echo "bindings/typescript/node_modules"
            ;;
        rust)
            # Cargo registry/git caches + target directory for compiled artifacts
            echo "${HOME}/.cargo/registry"
            echo "${HOME}/.cargo/git"
            echo "bindings/rust/target"
            ;;
        python)
            # pip cache + venv for installed packages
            echo "${HOME}/.cache/pip"
            echo "bindings/python/.venv"
            ;;
        go)
            # Go module cache + build cache
            echo "${HOME}/go/pkg/mod"
            echo "${HOME}/.cache/go-build"
            ;;
        ruby)
            # Bundler - use vendor/bundle (local to project)
            echo "bindings/ruby/vendor/bundle"
            ;;
        dart)
            # Dart/pub cache + .dart_tool for build artifacts
            echo "${HOME}/.pub-cache"
            echo "bindings/dart/.dart_tool"
            ;;
        java|kotlin)
            # Maven/Gradle cache + target/build directories
            echo "${HOME}/.m2/repository"
            echo "${HOME}/.gradle/caches"
            echo "bindings/java/target"
            echo "bindings/kotlin/build"
            ;;
        lua)
            # LuaRocks local tree
            echo "bindings/lua/.luarocks"
            ;;
        perl)
            # local::lib directory
            echo "bindings/perl/local"
            ;;
        csharp)
            # NuGet cache + obj/bin directories for build artifacts
            echo "${HOME}/.nuget/packages"
            echo "bindings/csharp/src/STRling/obj"
            echo "bindings/csharp/src/STRling/bin"
            echo "bindings/csharp/tests/STRling.Tests/obj"
            echo "bindings/csharp/tests/STRling.Tests/bin"
            ;;
        fsharp)
            # NuGet cache + obj/bin directories for build artifacts
            echo "${HOME}/.nuget/packages"
            echo "bindings/fsharp/src/STRling/obj"
            echo "bindings/fsharp/src/STRling/bin"
            echo "bindings/fsharp/tests/STRling.Tests/obj"
            echo "bindings/fsharp/tests/STRling.Tests/bin"
            ;;
        swift)
            # Swift Package Manager cache + .build directory
            echo "${HOME}/.swiftpm"
            echo "bindings/swift/.build"
            ;;
        c)
            # Build artifacts for C
            echo "bindings/c/build"
            ;;
        cpp)
            # CMake build directory
            echo "bindings/cpp/build"
            ;;
        r)
            # R package library
            echo "bindings/r/renv/library"
            ;;
        *)
            # Unknown language - return empty
            echo ""
            ;;
    esac
    exit 0
fi

# lockfile: Print the lockfile name for a given language (for CI cache key hashing)
# Outputs only the filename relative to the binding root
if [ "$COMMAND" == "lockfile" ]; then
    if [ -z "$LANG" ]; then
        echo ""
        exit 1
    fi
    case "$LANG" in
        php)
            echo "composer.lock"
            ;;
        typescript|javascript|node)
            echo "package-lock.json"
            ;;
        rust)
            echo "Cargo.lock"
            ;;
        python)
            # Python uses requirements.txt as the "lock" equivalent
            echo "requirements.txt"
            ;;
        go)
            # Go uses go.sum, but if no deps, fall back to go.mod
            if [ -f "bindings/go/go.sum" ]; then
                echo "go.sum"
            else
                echo "go.mod"
            fi
            ;;
        ruby)
            echo "Gemfile.lock"
            ;;
        dart)
            echo "pubspec.lock"
            ;;
        java)
            echo "pom.xml"
            ;;
        kotlin)
            echo "build.gradle.kts"
            ;;
        lua)
            echo "strling-3.0.0alpha-1.rockspec"
            ;;
        perl)
            echo "Makefile.PL"
            ;;
        csharp)
            echo "src/STRling/STRling.csproj"
            ;;
        fsharp)
            echo "src/STRling/STRling.fsproj"
            ;;
        swift)
            # Swift uses Package.resolved if it exists, otherwise Package.swift
            if [ -f "bindings/swift/Package.resolved" ]; then
                echo "Package.resolved"
            else
                echo "Package.swift"
            fi
            ;;
        c)
            echo "Makefile"
            ;;
        cpp)
            echo "CMakeLists.txt"
            ;;
        r)
            echo "DESCRIPTION"
            ;;
        *)
            echo ""
            ;;
    esac
    exit 0
fi

if [ -z "$LANG" ]; then
    echo "Error: Language argument is required for '$COMMAND'."
    echo "Usage: ./strling $COMMAND <language>"
    exit 1
fi


if [ ! -f "$TOOLCHAIN" ]; then
    echo "Error: toolchain.json not found at $TOOLCHAIN"
    exit 1
fi

# Handle 'setup all' command
if [ "$COMMAND" == "setup" ] && [ "$LANG" == "all" ]; then
    echo ">> WARNING: You're about to run setup for ALL bindings (this will install toolchains for 17+ languages and may consume significant disk space and take considerable time)."
    echo ">> Recommended: run a binding-specific setup instead, e.g. ./strling setup python"

    # Refuse to run in a non-interactive shell to avoid accidental usage in CI
    if [ ! -t 0 ]; then
        echo "Error: non-interactive shell detected. Aborting 'setup all'."
        echo "Run './strling setup <lang>' for a single binding instead."
        exit 1
    fi

    # Ask user to confirm explicitly
    read -p "Are you sure you want to continue? Type 'yes' to proceed: " CONFIRM
    if [[ "$CONFIRM" != "yes" ]]; then
        echo "Aborting 'setup all'. No changes made. Use './strling setup <lang>' for a single binding."
        exit 1
    fi

    echo ">> Running setup for ALL bindings..."

    # Get list of languages
    LANGS=$(python3 -c "import json; print(' '.join(json.load(open('$TOOLCHAIN'))['bindings'].keys()))")

    for L in $LANGS; do
        echo "--------------------------------------------------"
        echo ">> Setting up $L..."
        "$0" setup "$L"
    done
    exit 0
fi

# Handle 'clean' command
if [ "$COMMAND" == "clean" ]; then
    if [ "$LANG" == "all" ]; then
        echo ">> Cleaning global artifacts..."
        # Remove common build directories recursively
        # Exclude node_modules and .luarocks to avoid breaking dependencies
        # Path exclusions must come before -type d to be evaluated first
        find "$DIR" ! -path "*/node_modules/*" ! -path "*/.luarocks/*" -type d \( -name "build" -o -name "target" -o -name "dist" -o -name "vendor" -o -name "__pycache__" -o -name ".venv" -o -name ".pytest_cache" -o -name ".mypy_cache" \) -prune -exec rm -rf {} +
        echo ">> Global clean complete."
        exit 0
    else
        echo ">> Cleaning $LANG..."
        # For specific language, we might want to look up a clean command or just clean its directory
        # But for now, the requirement is mostly about the global clean.
        # Let's just warn that specific clean is not fully implemented or just do a targeted clean if we knew the path.
        # We can use the path from toolchain.
        
        # We need to fetch the path first, which happens below.
        # So we let it fall through to the normal logic? 
        # But toolchain.json doesn't have a 'clean' command.
        # So we should handle it here.
        
        # Let's fetch the path using the helper (we need to define it first or move this block down)
        # The helper is defined below. Let's move the helper up or duplicate logic?
        # Better to move the helper up.
        # But I can't easily move code with replace_string.
        # I'll just use the python one-liner again.
        
        BINDING_PATH=$(python3 -c "import json; try: print(json.load(open('$TOOLCHAIN'))['bindings']['$LANG']['path']); except: pass")
        if [ -z "$BINDING_PATH" ]; then
             echo "Error: Language '$LANG' not found in toolchain.json"
             exit 1
        fi
        
        TARGET_DIR="$DIR/$BINDING_PATH"
        echo ">> Cleaning artifacts in $TARGET_DIR..."
        find "$TARGET_DIR" -type d \( -name "build" -o -name "target" -o -name "dist" -o -name "vendor" -o -name "__pycache__" -o -name ".venv" \) -prune -exec rm -rf {} +
        echo ">> Clean complete for $LANG."
        exit 0
    fi
fi

# Helper to get value from JSON
get_json_value() {
    local key="$1"
    python3 - <<PY
import json
try:
    data=json.load(open('$TOOLCHAIN'))
    b=data['bindings'].get('$LANG', {})
    val=b.get('$key','')
    if isinstance(val, list):
        print(' '.join(val))
    else:
        print(val)
except Exception:
    pass
PY
}

# Helper to get command string from JSON (properly quoted)
get_cmd_string() { get_json_value "$1"; }

BINDING_PATH=$(get_json_value "path")
CHECK_BIN=$(get_json_value "check_bin")

if [ -z "$BINDING_PATH" ]; then
    echo "Error: Language '$LANG' not found."
    echo "Did you mean one of these?"
    python3 -c "import json; print('\n'.join(['  - ' + k for k in sorted(json.load(open('$TOOLCHAIN'))['bindings'].keys())]))"
    exit 1
fi

# Check if the required binary exists
# Check for required binary
if ! command -v "$CHECK_BIN" &> /dev/null; then
    echo "Error: Required tool '$CHECK_BIN' not found."
    case "$CHECK_BIN" in
        npm) echo "Hint: Install Node.js to work on TypeScript." ;;
        cargo) echo "Hint: Install Rust (rustup) to work on Rust." ;;
        go) echo "Hint: Install Go to work on Go." ;;
        python3) echo "Hint: Install Python 3 to work on Python." ;;
        dotnet) echo "Hint: Install .NET SDK to work on C# and F#." ;;
        cmake) echo "Hint: Install CMake to work on C++." ;;
        make) echo "Hint: Install Make to work on C." ;;
        java|mvn) echo "Hint: Install Java (JDK) and Maven to work on Java." ;;
        dart) echo "Hint: Install Dart SDK to work on Dart." ;;
        composer|php) echo "Hint: Install PHP and Composer to work on PHP." ;;
        luarocks) echo "Hint: Install Lua and LuaRocks to work on Lua." ;;
        *) echo "Hint: Please install '$CHECK_BIN' to proceed." ;;
    esac
    exit 1
fi

CMD_STRING=$(get_cmd_string "$COMMAND")

if [ -z "$CMD_STRING" ]; then
    echo "No '$COMMAND' command defined for $LANG."
    exit 0
fi

echo ">> Running $COMMAND for $LANG in $BINDING_PATH..."

cd "$DIR/$BINDING_PATH" || exit 1

# Python: create & use venv so pip doesn't try to write system files
if [[ "$LANG" == "python" ]]; then
    if [[ ! -d "$VENV_DIR" ]]; then
        echo ">> Creating Python virtual environment..."
        python3 -m venv "$VENV_DIR"
    fi
    export PATH="$(pwd)/$VENV_DIR/bin:$PATH"
    echo ">> Using python env: $(which python) (pip: $(which pip))"
fi

echo ">> Executing: $CMD_STRING"

# Safely split and run the command
read -r -a CMD_ARGS <<< "$CMD_STRING"

# Historically we exec'd dotnet directly to avoid a wrapper process.
# In some environments (including CI and certain WSL setups) replacing the shell
# process with dotnet could cause unexpected segfaults. Run dotnet normally so
# the wrapper stays alive and we can capture exit codes and logs reliably.
if [[ "${CMD_ARGS[0]}" == "dotnet" ]]; then
    echo ">> Running dotnet command in a clean shell to avoid direct-invocation issues"
    bash -lc "$CMD_STRING"
else
    "${CMD_ARGS[@]}"
fi
EXIT_CODE=$?
if [[ $EXIT_CODE -ne 0 ]]; then
    echo ""
    echo "‚ùå Command failed with exit code $EXIT_CODE"
    echo "   Task: $COMMAND"
    echo "   Language: $LANG"
    if [ "$COMMAND" == "test" ] || [ "$COMMAND" == "build" ]; then
        echo "   Hint: Try running './strling setup $LANG' first."
    fi
    exit $EXIT_CODE
fi

